szl
===
Dima Krasner <dima@dimakrasner.com>
:Author Initials: DK
:numbered:
:website: http://github.com/dimkr/szl

:toc:

Introduction
------------
+szl+ (pronounced "sizzle") is a scripting language inspired by
http://www.tcl.tk/[Tcl], shell and http://www.python.org/[CPython], which
follows four design principles:

1. There should be only *one, obvious way* to achieve a certain effect
2. Consistency:
- Every statement is a procedure call
- Everything is an object
- Every object is a string
3. Minimal, low-level standard library which leaves high-level logic to the user
4. One-liners are first-class citizens and *not* frowned upon

[quote, 'Vincent Van Gogh']
Great things are ... done by a series of small things brought together.

The +szl+ interpreter is designed as a library and exposes a high-level API. It
strives to provide reasonable performance at tiny code size, to make it
attractive as an embedded scripting engine integrated into other projects.

[NOTE]
The term "+szl+" refers to *both* the programming language and its official
interpreter, depending on the context.

This Document
-------------
This is a comprehensive manual, for the +szl+ user or for developers who wish to
extend +szl+ or integrate it into their projects.

[WARNING]
This manual may reflect a future state of +szl+.

Use Cases
~~~~~~~~~
+szl+ is especially useful when:

1. One needs a swiss knife, "shell on steroids" for automation or DevOps
   scripts, but shell scripting isn't powerful enough (because shell language
   lacks programming language features such as exceptions), while other
   languages are too powerful and require too much work to execute processes and
   read their output.
2. One needs a way to write a highly scalable and reliable server, but C APIs
   like +epoll+ make correct memory management and error handling (which affect
   scalability, security and reliability over time) hard to achieve in C,
   because memory management is manual and crash-prone, while errors cannot be
   handled using exceptions, because C lacks this feature. +szl+ wraps low-level
   interfaces like +epoll+, +timerfd+ and +signalfd+ with a simpler interface
   but with very little overhead, while providing automatic garbage collection,
   exceptions and complex data types useful for servers (i.e. dictionaries that
   map sockets to session data).
3. A systems person needs a quick n' dirty way to call C functions, without
   having to do native development during early research or the prototype phase:
   +szl+ allows interfacing with C code and data types via scripts!
4. One needs an embedded interpreter in a big software project, used as a logic
   layer, high-level glue between components written in different languages or
   as a scripting engine for advanced users (for example, in a console window of
   an action game).
5. A complex task is very hard or impossible to accomplish using nothing but
   traditional *nix tools (such as +sh+, +nc+, +tar+ and +cut+): +szl+
   implements sockets, string operations, compression, archiving and more, while
   maintaining the simplicity of shell scripting.
6. One needs an extremely lightweight scripting language, for quick development
   of programs that run on underpowered hardware, such as cheap Wi-Fi routers.
7. One wants to introduce non-technical people to programming, using an easy to
   learn scripting language with a simple syntax.

To sum up, +szl+ is a simple scripting language useful use as an alternative to
shell scripting and as a language for quick, safe system programming. Its safe,
consistent syntax contributes to clarity and prevents edge cases usually found
in shell scripts, like bad handling of input that contains spaces.

History
~~~~~~~
+szl+ began its life as a pet project: a clean-room, partial re-implementation
of http://jim.tcl.tk/[jimtcl], for self-education purposes.

However, quickly enough, as more and more new ideas were translated into code,
+szl+ evolved into a much different beast.

Tutorial
--------
[quote, 'Friedrich Nietzsche']
The doer alone learneth.

Getting Started
~~~~~~~~~~~~~~~
Each and every +szl+ script is a series of statements in the following form:

--------------------------------------
$proc arg arg
--------------------------------------

Every +szl+ statement describes an operation on one or more objects. Objects may
be:

1. Textual (strings),
2. Numeric (integers and floating-point numbers), or
3. Lists (a series of objects)

Each statement is a series of space-delimited tokens, while each token
corresponds to an object.

The first object in a statement must be a procedure (think, _function_).
The procedure receives the rest of the objects as arguments (input), does
something and returns an object (output). For example, in the following
statement, the '+' procedure receives '1', and '2' as arguments and returns
'3' as output:

[NOTE]
Some procedures do not receive any arguments.

--------------------------------------
$+ 1 2
--------------------------------------

Each object is identified by a unique name. To access the value of an object,
prefix its name with '$'. For example, to call the 'puts' procedure:

--------------------------------------
$puts hello
--------------------------------------

Since 'hello' is not prefixed with '$', a temporary object containing 'hello' is
passed to 'puts'.

To name a new object, use either 'local' or 'global'. For example, to create
an object named 'number', with the value of '5':

--------------------------------------
$local number 5
$puts $number
--------------------------------------

When an object is no longer used, +szl+ will automatically free all resources
associated with it.

Lines that begin with '#' are comments and ignored by the interpreter:

--------------------------------------
# this is a very useful script
$local number 5
--------------------------------------

To run a script, either run +szlsh+ to run each statement interactively or save
the script to a file and run +szl+:

--------------------------------------
$ szl script.szl
--------------------------------------

Lists
~~~~~
In +szl+, *everything* is a string. All objects are represented as strings and
+szl+ knows how to treat them, depending on the context. For example, once two
objects are passed to the '+' procedure, they are treated as numbers.

Lists are strings wrapped with braces:

--------------------------------------
$local message {hello world}
--------------------------------------

In this example, 'local' accepts two arguments: 'message' and 'hello world'.

In addition, strings enclosed in braces may contain multiple lines. For example,
the second argument of 'if' is a block of one or more +szl+ statements:

--------------------------------------
$if 1 {
	$puts hello
	$puts world
}
--------------------------------------

This block of statements is a list, while a list is a string. To sum it up:
*everything* in +szl+ is a string and every string is an object.

[NOTE]
A block can be idented using either spaces, tabs or both. Whitespace at the
beginning or end of statements is ignored.

Using Return Values
~~~~~~~~~~~~~~~~~~~
To obtain the return value of a statement, wrap it with brackets. A statement
enclosed in brackets is executed and replaced with its return value.

For example, the following example executes '$+ 1 2.5' and passes '3.5' (the
return value of '+') to 'local', as its second argument:

--------------------------------------
$local sum [$+ 1 2.5]
--------------------------------------

[NOTE]
Every procedure has a return value. If a procedure does not specify a return
value, it returns an empty string.

[TIP]
The return value of the previously called procedure is stored in the special '_'
object, in the calling scope.

Both braces and brackets may be nested, to call multiple procedures in the same
line:

--------------------------------------
$local sum [$- [$str.len {hello world}] 3]
--------------------------------------

Special Characters
~~~~~~~~~~~~~~~~~~
Special characters such as line breaks can be used in object declarations, using
a backslash ('\') and 'str.expand':

--------------------------------------
$local tabs [$str.expand \t\t]
--------------------------------------

Formatting Strings
~~~~~~~~~~~~~~~~~~
To form more complex strings, such as user-friendly messages, use 'str.format':

--------------------------------------
$puts [$str.format {the sum of {} and {} is {}} 3 4 [$+ 3 4]]
--------------------------------------

'str.format' accepts a format string (or, a template) and replaces
occurrences of '{}' with the arguments that follow.

Declaring Procedures
~~~~~~~~~~~~~~~~~~~~
+szl+ can be extended with additional procedures, using 'proc'. The following
example defines a procedure called 'print_hello' and calls it:

--------------------------------------
$proc print_hello {
	$puts hello
}

$print_hello
--------------------------------------

Procedure arguments are accessible using objects named '1', '2' and so on. The
following procedure prints its first argument ('hello'):

--------------------------------------
$proc print_something {
	$puts $1
}

$print_something hello
--------------------------------------

In addition, a procedure may access its list of arguments, via the special '@'
object:

--------------------------------------
$proc print_statement {
	$puts [$str.format {invoked with arguments: {}} $@]
}

$print_statement a b {c d} e f {g h}
--------------------------------------

[NOTE]
When accessed outside of a procedure, '@', '0', etc' specify the command-line
arguments +szl+ was invoked with.

The return value of a procedure is either:

1. The value passed to 'return', if 'return' was called within the procedure
   body ...
2. **or** the return value of the last statement of the procedure body, if
   'return' was not called

For example, the following functions are identical, functionality-wise:
--------------------------------------
$proc foo {
	$puts {before check}
	$== 1 2
}

$proc bar {
	$puts {before check}
	$return [$== 1 2]
	$puts {after check}
}
--------------------------------------

Streams
~~~~~~~
The most important concept in +szl+ is the stream. Streams are objects which can
be either read from, written to or both. +szl+ represents network connections,
open files, child processes and various events as streams. Therefore, operations
on all these objects or resources are performed via a uniform interface.

In addition, streams can be used with polling objects created using
'poll.create': this allows a +szl+ script to act as an event-handling loop. For
example, a server that handles concurrent connections may be implemented as a
loop that waits for new connections, incoming data that arrives through existing
connections, timer events that notify a session has timed out, signals that
notify the server it should re-read its configuration and so on.

Using Extensions
~~~~~~~~~~~~~~~~
To obtain access to more procedures, +szl+ provides an extensions mechanism. For
example, to be able to compress files using the 'zlib.gzip' procedure, the
'zlib' extension should be loaded:

--------------------------------------
$load zlib
--------------------------------------

Using Modules
~~~~~~~~~~~~~
In addition, large +szl+ scripts can be split into several files (or "modules"),
for easier maintenance and the ability to share parts (like helper procedures)
between projects. For example, utility procedures can be put in 'util.szl'.
Then, 'source' can be used to execute this file through the script body:

--------------------------------------
$source util.szl
--------------------------------------

Standard Library
----------------
Builtin Procedures
~~~~~~~~~~~~~~~~~~
Objects
^^^^^^^
+$echo+ 'obj'::
	Returns 'obj'.

--------------------------------------
$== [$echo 5] 5
--------------------------------------

+$get+ 'name'::
	Returns the object named 'name'.

--------------------------------------
$local a 5
$== [$get a] 5
--------------------------------------

+$repr+ 'obj'::
	Returns a nicely printable representation of 'obj', where binary data and
	non-English characters are converted to hexadecimal form (e.g. '\xff').

+$hex+ 'val'::
	Returns the hexadecimal representation of an integer.

Objects
+++++++
+$local+ 'name val'::
	Creates a new object in the local scope.

[TIP]
'local' returns the object value, which is useful for one-liners (for example,
when one wishes to create a new object and pass its value to another procedure).

+$export+ 'name ?val?'::
	Creates a local object in the calling scope. If no value is specified, the
	value of the local object with the same name is used as fallback.

--------------------------------------
$proc check_if_bigger_than_ten {
	$local bigger 0
	$if [$> $1 10] {$export bigger 1}
	$puts $bigger
}

$check_if_bigger_than_ten 12
--------------------------------------

+$global+ 'name val'::
	Similar to 'local', but creates the new object in the global scope. The
	object will be accessible from all procedures.

[NOTE]
If a procedure uses 'local' to define a local object with the same name as a
previously defined global object, attempts to obtain the object value from
within the procedure will refer to the local one.

String Operations
+++++++++++++++++

[WARNING]
Internally, +szl+ stores all strings in 'UTF-8' encoding and all string
procedures (e.g. 'str.len') are character-, rather than byte-oriented. Use
byte-oriented procedures (e.g. 'byte.range') when working with binary data.

+$str.len+ 'str'::
	Returns the length of a string.

+$str.count+ 'str sub'::
	Returns the number of occurrences of 'sub' in 'str'.

+$str.range+ 'str start end'::
	Returns the characters in a string, between zero-based indices 'start' and
	'end'.

+$str.find+ 'str sub ?start?'::
	Returns the zero-based index of the first of occurence of 'sub' in 'str',
	between offset 'start' and the end of 'str'.

+$str.in+ 'str sub'::
	Returns '1' if 'sub' is a substring of 'str', otherwise '0'.

+$str.tail+ 'str ?count?'::
	Returns the last characters of a string. If the number of characters is not
	specified, the default is '1'.

+$str.starts+ 'str sub'::
	Returns '1' if 'str' starts with 'sub', otherwise '0'.

+$str.ends+ 'str sub'::
	Returns '1' if 'str' ends with 'sub', otherwise '0'.

+$str.append+ 'name str'::
	Appends a string to an existing str.

+$str.split+ 'str delim'::
	Splits a string consisting of tokens separated by 'delim'. 'delim' may be an
	empty string to return a list of all characters in the string.

+$str.join+ 'delim str str ?...?'::
	Joins multiple strings, with a delimiter (which may be an empty string).

[NOTE]
'str.join' is the most efficient way to concatenate more than two strings.

+$str.expand+ 'str'::
	Expands escape sequences in a string: '\0', '\\', '\n', '\t', '\r' and
	hexadecimal numbers in '\x' notation (e.g. '\xff').

--------------------------------------
$puts [$str.expand {this is a\n\tmulti-line strin\x67}]
--------------------------------------

+$str.format+ 'fmt obj...'::
	Receives a format string and replaces all occurrences of '{}' with their
	values.

--------------------------------------
$puts [$str.format {the length of "{}" is {}} abcd [$str.len abcd]]
--------------------------------------

+$str.rtrim+ 'str'::
	Removes whitespace at the end of a string.

+$str.ltrim+ 'str'::
	Removes whitespace at the beginning of a string.

+$str.trim+ 'str'::
	Removes whitespace at both ends of a string.

Byte Operations
+++++++++++++++
+$byte.len+ 'buf'::
	Returns the size of a string, in bytes.

+$byte.range+ 'buf start end'::
	Returns the bytes in a buffer, between zero-based indices 'start' and 'end'.

+$byte.ord+ 'buf'::
	Returns the integer value of each byte of a buffer.

List Operations
+++++++++++++++
+$list.new+ '?item...?'::
	Creates a new list.

+$list.len+ 'list'::
	Returns the number of items in a list.

+$list.range+ 'list start end'::
	Returns the items in a list, between zero-based indices 'start' and 'end'.

--------------------------------------
$local fruits {apple orange pear}
$puts [$str.format {the first two fruits are: {}} [$list.range $fruits 0 1]]
--------------------------------------

+$list.in+ 'list item'::
	Returns '1' if 'item' is an item of 'list', otherwise '0'.

--------------------------------------
$local fruits {apple orange pear}
$puts [$list.in $fruits orange]
$puts [$list.in $fruits melon]
--------------------------------------

+$list.append+ 'list item'::
	Appends an object to a list.

--------------------------------------
$local fruits {apple orange}
$list.append $fruits pear
$puts $fruits
--------------------------------------

+$list.join+ 'delim list'::
	Joins the items of a list to form a string.

--------------------------------------
$puts [$str.format {three fruits: {}} [$list.join , {apple orange pear}]]
--------------------------------------

+$list.set+ 'list index item'::
	Replace a list item.

--------------------------------------
local fruits {apple orange}
$list.set $fruits 1 banana
$puts $fruits
--------------------------------------

+$list.extend+ 'list list'::
	Adds all items in a list to an existing one and returns it.

--------------------------------------
$local fruits {apple orange}
$puts [$list.extend $fruits {pear banana}]
$puts $fruits
--------------------------------------

+$list.zip+ 'list list...'::
	Returns a list of lists, each containing the 'n'-th elements of given lists
	of the same length.

--------------------------------------
$for pair [$list.zip {apple orange pear} {red orange green}] {
	$puts [$str.format {{}s are {}} [$list.index $pair 0] [$list.index $pair 1]]
}
--------------------------------------

+$list.reverse+ 'list'::
	Returns all items in a list, in reverse order.

+$list.index+ 'list index'::
	Returns the list item at the zero-based position 'index'.

+$range+ '?start? end'::
	Returns a list of integers in a given range. The maximum is non-inclusive.
	If no minimum is specified, the range starts at '0'.

--------------------------------------
$for i [range 1 11] {$puts $i}
--------------------------------------

Arithmetic and Logical Operations
+++++++++++++++++++++++++++++++++
+$++ 'm n'::
	Returns 'm + n'.

+$-+ 'm n'::
	Returns 'm - n'.

+$*+ 'm n'::
	Returns 'm * n'.

+$/+ 'm n'::
	Returns 'm / n'.

+$%+ 'm n'::
	Returns 'm - x', where 'x' is the floor of 'm / n'.

+$&+ 'm n'::
	Returns bitwise 'm & x'.

+$|+ 'm n'::
	Returns bitwise 'm | x'.

+$^+ 'm n'::
	Returns bitwise 'm ^ x'.

+$==+ 'obj obj'::
	Returns '1' if two objects are equal, otherwise '0'.

+$!=+ 'obj obj'::
	Returns '1' if two objects are not equal, otherwise '0'.

+$>+ 'm n'::
	Returns '1' if 'm' is greater than 'n', otherwise '0'.

+$>=+ 'm n'::
	Returns '1' if 'm' is greater than or equal to 'n', otherwise '0'.

+$<+ 'm n'::
	Returns '1' if 'm' is less than 'n', otherwise '0'.

+$\<=+ 'm n'::
	Returns '1' if 'm' is less than or equal to 'n', otherwise '0'.

+$&&+ 'obj obj...'::
	Returns '1' if all conditions are true, otherwise '0'.

+$||+ 'obj obj...'::
	Returns '1' if at least one condition is true, otherwise '0'.

+$^^+ 'obj obj'::
	Returns '1' if one condition is true and the other is false, otherwise '0'.

--------------------------------------
$if [$&& [$== [$+ 1 1] 2] [$== [$+ 2 2] 4]] {$puts yes}
--------------------------------------

+$!+ 'obj'::
	Returns '0' if a condition is true, otherwise '1'.

+$is+ 'obj obj'::
	Determines whether two objects are the same object.

[NOTE]
Unlike '==', 'is' does not compare objects. For example, there may be two
different objects with the value '5'. In such cases, 'is' will return '0'.

+$id+::
	Returns a random number which can be used in a procedure name.

Procedures
^^^^^^^^^^
+$proc+ 'name exp ?priv?'::
	Defines a new procedure. Optionally, the procedure may store private data in
	'.'.

+$return+ '?obj?'::
	Stops the execution of a procedure and sets its return value. If no return
	value is specified, the procedure returns an empty string.

+$stack+ '?lim?'::
	Returns all statements or only the bottom 'lim' statements, in the stack of
	procedure calls that lead to the the 'stack' call.

+$load+ 'name'::
	Loads a 'szl' extension, to make additional procedures available.

+$syscall+ 'num arg...'::
	Performs a system call.

[TIP]
'syscall' is useful when one wishes to perform a system call without having to
implement a 'szl' extension.

[TIP]
Use the 'ffi' extension to create pointers that can be passed to 'syscall'.

Flow Control
^^^^^^^^^^^^
+$if+ 'cond exp ?else exp?'::
	Conditionally runs a block.

+$switch+ 'obj val exp val exp...'::
	For each pair of a value and a block, compares an object to the value and
	runs the block and stops if they are equal, or if the value is '*'.

--------------------------------------
$switch [$+ 1 2] 2 {
	$puts {it is 2}
} 3 {
	$puts {it is 3}
} 4 {
	$puts {it is 4}
} * {
	$puts {unknown result}
}
--------------------------------------

+$while+ 'cond exp'::
	Runs a block as long as a condition is met.

+$do+ 'exp while cond'::
	Similar to 'while', but checks the condition after the first execution of
	the loop body.

+$map+ 'names list exp'::
	For each series of items in a list, runs a block with local object that
	specify the items and returns a list of the block return values.

--------------------------------------
$puts [$map {a b} {1 1 1 2 1 3 1 4} {$+ $a $b}]
--------------------------------------

[TIP]
'map' is particularly useful for elegant one-liners, at the cost of memory
usage (since the block return values are collected in a new list).

+$for+ 'name list exp'::
	Same as 'map', but discards the block return values.

--------------------------------------
$for {a b} {1 2 3 4 5 6 7 8} {
	$puts [$str.format {a is {} and b is {}} $a $b]
}
--------------------------------------

+$break+::
	Stops the execution of a loop.

+$continue+::
	Stops the execution of a loop body and continues to the next iteration.

+$exit+ '?obj?'::
	Stops the execution of the script and optionally, sets its return value.

+$sleep+ 'sec'::
	Suspends the script execution for a given interval, specified in seconds.
	The interval may be a floating-point number (e.g. '4.5').

+$call 'exp'+::
	Runs a single +szl+ statement in the current scope.

+$eval+ 'exp'::
	Evaluates a +szl+ expression in the current scope.

+$source+ 'path'::
	Execute a 'szl' script in the global scope.

Exceptions
++++++++++
+$try+ 'exp ?except exp? ?finally exp?'::
	Runs an block. Optionally, if a statement failed, jumps to a second, error
	handling block. Unconditionally, a third (usually, cleanup code) block is
	executed afterwards. The error handling block can access the error string
	via '_', like this:

--------------------------------------
$try {
	$puts
} except {
	$puts [$str.format {caught an error: {}} $_]
} finally {
	$puts {Always executed}
}
--------------------------------------

[TIP]
Any block can be wrapped with 'try' block without a matching 'except', to
silently ignore errors.

+$throw+ '?msg?'::
	Triggers an error condition and optionally specifies an explanation. The
	error condition may be caught by a 'try' call.

--------------------------------------
$try {
	$throw {some error description}
} except {
	$puts [$str.format {caught an error: {}} $_]
}
--------------------------------------

Interpreters
++++++++++++
+$szl.interp+ '?args?'::
	Creates a new +szl+ interpreter, with 'args' as its arguments (e.g. '$@').
	If 'args' is unspecified, the new interpreter inherits the calling
	interpreter's arguments.

+$interp+ 'eval exp'::
	Evaluates a +szl+ expression in an interpreter.

+$szl.shell+::
	Runs an interactive +szl+ interpreter.

+$szl.main+::
	Runs an interactive +szl+ interpreter; upon error, prints it and exits.

I/O
^^^
+$puts+ 'msg'::
	Prints an object to standard output. If the object does not end with a line
	break ('\n'), a line break character is appended.

+$null+::
	A stream that acts like an empty file. Every attempt to read from it returns
	an empty string every attempt to write to it succeeds.

+$stdin+::
+$stdout+::
+$stderr+::
	Streams representing standard input, output and error output, respectively.

File System
^^^^^^^^^^^
+$path.sep+::
	The separator between path components.

+$path.join+ 'str...'::
	Joins path components.

--------------------------------------
$local path [$path.join .. something.txt]
--------------------------------------

[TIP]
To join path components in a portable way, use 'path.join'.

+$path.exists+ 'path'::
	Checks whether a file exists.

+$path.isdir+ 'path'::
	Checks whether a path points to a directory.

+$path.realpath+ 'path'::
	Returns the absolute, canonical path of a file.

+$file.size+ 'path'::
	Returns the size of a file.

+$file.delete+ 'path'::
	Deletes a file.

+$file.lock+ 'path'::
	Creates a lock file, locks it and returns a lock file object.

[NOTE]
If another process locks the file, 'file.lock' will block until it is released.

+$lock+ 'unlock'::
	Unlocks a lock file.

[NOTE]
Leftover lock files are unlocked automatically, during garbage collection.

+$file.locked+ 'path'::
	Checks whether a lock file is locked.

+$dir.create+ 'path'::
	Creates a directory.

+$dir.delete+ 'path'::
	Deletes an empty directory.

+$dir.rdelete+ 'path'::
	Recursively deletes the contents of a directory and the directory itself.

+$cd+ 'path'::
	Changes the working directory.

File Operations
+++++++++++++++
+$open+ 'path ?mode?'::
	Opens a file and returns a stream object. 'mode' is 'fputs()'-style: 'r'
	(the default), 'w', 'a', 'r+', 'w+' or 'a+' (see 'man fputs' for the meaning
	of each mode). By default, reading and writing is line-buffered.

[NOTE]
'mode' can be suffixed with 'b' to enable full buffering instead of line-based
buffering, which improves efficiency with binary files.

[NOTE]
'mode' can be suffixed with 'u' to disable buffering, which improves efficiency
when 'read' is called only once (for example, when the entire file is read at
once).

+$stream+ 'read ?len?'::
	Reads a 'len' bytes from a stream, or its entire contents. If the stream is
	non-blocking and less than 'len' bytes are available for reading without
	waiting, that will be the number of bytes returned.

+$stream+ 'readln'::
	Reads from a stream, until line end or until no more data can be read.

+$stream+ 'write str'::
	Writes a string to a stream. If the stream is non-blocking and only a part
	of the string could be written without waiting, the procedure will return
	the number of bytes written.

+$stream+ 'writeln str'::
	Writes a string to a stream. If the string does not end with a line break
	('\n'), a line break character is appended.

[NOTE]
Since writing operations on files may be buffered to improve efficiency, data
passed to 'write' or 'writeln' is not guaranteed to be written to the stream
immediately. To flush queued data to disk, call 'flush'.

+$stream+ 'flush'::
	Flushes the output buffer of a stream.

+$stream+ 'unblock'::
	Enables non-blocking operation on a stream.

+$stream+ 'rewind'::
	Moves future 'read' or 'write' operations on a stream back to its beginning.

+$stream+ 'setopt opt val'::
	Enables or disables stream-type specific option.

+$stream+ 'handle'::
	Returns an opaque value (an integer) that represents a stream, suitable for
	'poll'.

+$stream+ 'close'::
	Closes a stream.

[NOTE]
'close' is called automatically during garbage collection. In many cases, an
implicit 'close' call is redundant and trivial file operations can be
implemented as one-liners:

--------------------------------------
$local content [[$open /etc/hosts ru] read]
--------------------------------------

+$isatty+ 'handle'::
	Determines whether a file handle refers to a terminal.

+$sync+::
	Flushes all file system buffers to disk.

Sockets
^^^^^^^
+$stream.client+ 'host service'::
	Creates a new TCP socket and connects to 'host:service'.

+$socket+ 'setopt cork val'::
	Enables ('1') or disables ('0') the 'TCP_CORK' option, as described in
	+tcp(7)+.This may increase throughput, if 'write' is called multiple times
	and sent data can be queued.

+$dgram.client+ 'host service'::
	Creates a new UDP socket which sends datagrams to 'host:service'.

+$dgram.server+ 'host service'::
	Creates a new UDP socket and listens on 'host:service'.

+$stream.server+ 'host service ?backlog?'::
	Creates a new TCP socket, listens on 'host:service' and holds up to
	'backlog' pending clients (i.e. clients awaiting 'accept'). If 'backlog' is
	not specified, the default is '5'.

[NOTE]
If 'service' is an empty string, the socket is bound to the wildcard address.

[TIP]
Sockets behave very much like files (e.g. they provide 'read' and 'write').
During testing, sockets can be easily swapped with files to simulate incoming
data.

+$socket+ 'accept'::
	Waits for a client to connect the socket and returns a new socket.

Socket I/O Multiplexing
+++++++++++++++++++++++
+$poll.create+::
	Creates a new set of polled sockets, timers and signal streams.

+$poll+ 'add handle event...'::
	Adds a handle to a set and enables monitoring of specific events. Currently
	supported event types are 'in' (data available for immediate 'read') and
	'out' (ability to 'write' without waiting).

+$poll+ 'remove handle'::
	Removes a handle from a set.

+$poll+ 'wait lim'::
	Waits for up to 'lim' socket, timer or signal events and returns three lists
	of handles: those ready for reading, writing or error handling.

+$timer+ 'interval'::
	Creates a non-readable stream, which triggers an 'in' event after 'interval'
	seconds.

Processes
^^^^^^^^^
+$getpid+::
	Returns the process ID of the +szl+ interpreter.

+$exec+ 'cmd'::
	Runs a shell command and returns a new stream representing it. Data written
	to the stream is passed to the shell command's standard input pipe and data
	the shell command's  output be read through the stream.

[TIP]
'exec' passes 'cmd' to the default shell, so 'cmd' may rely on shell features
such as redirection:
--------------------------------------
$puts [[$exec {uname -a 2>/dev/null}] read]
--------------------------------------

Signals
^^^^^^^
+$signal+ 'sig...'::
	Blocks a list of signals and returns a stream which outputs received signal
	numbers.

+$sigint+::
	The +SIGINT+ signal number.

+$sigterm+::
	The +SIGTERM+ signal number.

+$sigchld+::
	The +SIGCHLD+ signal number.

+$sigusr1+::
	The +SIGUSR1+ signal number.

+$sigusr2+::
	The +SIGUSR2+ signal number.

+$kill+ 'pid ?sig?'::
	Sends a signal. If no signal is specified, the signal is 'SIGTERM'.

+$wait+::
	Waits for a child process to terminate and returns its exit code.

Environment
^^^^^^^^^^^
+$env.get+ 'name'::
	Returns the value of an environment variable.

+$env.ver+::
	The +szl+ version.

+$env.intmax+::
	The maximum value of a C 'int', on the hardware architecture +szl+ runs on.
	This value is useful as an upper limit for input sanity checks (for example,
	the maximum size of a file specified by the user).

Extensions
~~~~~~~~~~
oop
^^^
The 'oop' extension implements classes with multiple inheritance, to allow a
basic form of object-oriented programming.

+$class+ 'name code ?base...?'::
	Creates a class object. Class methods should be declared using 'method' and
	may call its own methods via 'this' and store instance variables in 'data'.

+$klass+::
	Creates a new instance of a class.

+$klass+ 'methods'::
	Lists the methods associated with a class.

+$super+ 'klass ?args...?'::
	Calls a base class method.

--------------------------------------
$load oop

$class food {
	$method is_tasty {
		$return 0
	}

	$method size {
		$dict.get $data size s
	}

	$method enlarge {
		$dict.set $data size $1
	}
}

$class carrot {
	$method size {
		$dict.get $data size m
	}

	$method enlarge {
		$super $food enlarge xl
	}
} $food

$class rice {
	$method is_tasty {
		$return 1
	}

	$method enlarge {
		$super $food enlarge l
	}
} $food

$for dish [$list.new [$rice] [$carrot]] {
	$puts [$dish is_tasty]
	$puts [$dish size]
	$dish enlarge
	$puts [$dish size]
}
--------------------------------------

Compression
^^^^^^^^^^^
zlib
++++
The 'zlib' extension is a +szl+ wrapper for http://zlib.net/[zlib], a general
purpose data compression library.

+$zlib.crc32+ 'str ?init?'::
	Returns the CRC32 checksum of a buffer. Optionally, an initial value may be
	specified; this is most useful for calculating the checksum of chunked data
	read from a stream (for instance, a pipe).

+$zlib.deflate+ 'str ?level?'::
	Compresses a buffer and outputs a raw, Deflate-compressed stream.
	Optionally, a compression level ('1'-'9') may be specified to choose the
	desired speed vs. compression rate ratio.

+$zlib.inflate+ 'str ?bufsiz?'::
	Decompresses a raw, Deflate-compressed stream. When the uncompressed data
	size is known and specified, memory allocation is *more efficient*.
	Otherwise, decomperssion is chunked and therefore slower.

+$zlib.gzip+ 'str ?level?'::
	Compresses a buffer and adds a gzip header.

--------------------------------------
#!/usr/bin/env szl
# A trivial szl implementation of gzip(1)

$load zlib

$if [$== [$list.len $@] 2] {
	$local dest [$str.format {{}.gz} $1]
	$local in [$open $1 ru]
	$local out [$open $dest wu]
	$try {
		$out write [$zlib.gzip [$in read]]
	} except {
		$out close
		$file.delete $dest
		$exit 1
	}
	$file.delete $1
} else {
	$stdout write [$zlib.gzip [$stdin read]]
}
--------------------------------------

+$zlib.gunzip+ 'str ?bufsiz?'::
	Decompresses a gzip-compressed buffer. Decompression is chunked, with a
	default, *small* buffer size of 64K which guarantees lower memory
	footprint at the cost of speed. It is *highly recommended* to use a bigger
	size, on systems without a severe memory constraint.
	The following script is a trivial +szl+ implementation of +gunzip(1)+:

--------------------------------------
#!/usr/bin/env szl
# A trivial szl implementation of gunzip(1)

$load zlib
$stdout write [$zlib.gunzip [$stdin read] 524288]
--------------------------------------

lzfse
+++++
The 'lzfse' extension is a +szl+ wrapper for
https://github.com/lzfse/lzfse/[lzfse], a data compression library.

+$lzfse.compress+ 'str'::
	Compresses a buffer.

+$lzfse.decompress+ 'str'::
	Decompresses a buffer.

zstd
++++
The 'zstd' extension is a +szl+ wrapper for
https://github.com/facebook/zstd[Zstandard], a data compression library.

+$zstd.max+::
	The maximum 'Zstandard' compression level.

+$zstd.compress+ 'str ?level?'::
	Compresses a buffer. Optionally, a compression level ('0' to '$zstd.max')
	may be specified to choose the desired speed vs. compression rate ratio.

+$zstd.decompress+ 'str ?size?'::
	Decompresses a buffer. If the uncompressed data size is known, it should be
	specified. Otherwise, the procedure attempts to guess it.

Network
^^^^^^^
tls
+++
The 'tls' extension implements secure, Transport Layer Security (TLS) wrapped
TCP sockets, through http://www.openssl.org/[OpenSSL] or a compatible library
such as http://www.libressl.org/[LibreSSL].

+$tls.connect+ 'handle'::
+$tls.accept+ 'handle cert priv'::
	Starts a TLS handshake via an existing, connected socket and returns a new
	stream.

curl
++++
The 'curl' extension implements file download via multiple protocols, through
https://curl.haxx.se/[cURL].

+$curl.encode+ 'str'::
	URL-encodes a string.

+$curl.get+ 'url path...'::
	Downloads multiple files in parallel.

server
++++++
The 'server' extension implements common, core server logic.

+$server.tcp+::
	A class that implements a TCP echo server. Subclasses should override the
	'accept' and 'get_response' methods.

+$server+ 'serve host port backlog timeout'::
	Starts a TCP echo server which listens on 'host:port', with a queue of up to
	'backlog' incoming clients and a timeout of 'timeout' seconds for each
	connection.

http
++++
The 'http' extension is a high-level interface for sending HTTP requests, mostly
useful for working with REST APIs.

+$http.get+ 'host port tls url params'::
	Sends a 'GET' request to 'host:port/url' with 'params'. If 'tls' is true,
	the request is sent over HTTPS. 'params' should be a dictionary that maps
	parameter names to their values. The return value is a list of two items:
	the HTTP status code and the response body.

--------------------------------------
$load http

$puts [$list.index [$http.get httpbin.org 443 1 /get [$dict.new a {123 456} b 789]] 1]
--------------------------------------

+$http.post+ 'host port tls url params'::
	Similar to 'http.get', but sends a 'POST' request instead.

+$http.codes+::
	A dictionary that maps HTTP status codes (e.g. '200') to their textual
	representation (e.g. 'OK').

+$http.server+::
	A class that implements a HTTP server.

+$server+ 'serve host port backlog timeout'::
	Runs a HTTP server.

https
+++++
The 'https' extension implements a HTTP server.

+$https.server+::
	A class that implements a HTTPS server.

+$server+ 'serve host port backlog timeout cert priv'::
	Runs a HTTPS server.

resp
++++
The 'resp' extension implements a basic http://redis.io/topics/protocol[RESP]
server which can be used to store data, like http://redis.io/[Redis].

+$resp.server+::
	A class that implements a RESP server.

+$server+ 'serve host port backlog timeout'::
	Runs a RESP server.

dict
^^^^
The 'dict' extension is a trivial, +szl+ implementation of associative arrays on
top of sorted lists.

+$dict.new+ ?k v...?::
	Creates a new dictionary. If no initial contents are specified, the
	dictionary will be empty.

+$dict.set+ 'dict k v'::
	Sets the dictionary value associated with a key.

+$dict.get+ 'dict k ?v?'::
	Returns the dictionary value associated with a key. If the key is missing
	and no fallback value is specified, an exception is thrown.

test
^^^^
The 'test' extension provides test helpers.

+$test.run+ 'desc throws exp result'::
	Runs 'exp' and compares its result or the error it throws (depending on the
	'throws' flag) to 'result'.

ffi
^^^
The 'ffi' extension is a +szl+ wrapper for
http://sourceware.org/libffi/[libffi] and provides an interface to C data types,
raw memory operations and C function calls through +szl+ scripts.

Data Types
++++++++++
+$ffi.int8+ '?val?'::
+$ffi.uint8+ '?val?'::
+$ffi.int16+ '?val?'::
+$ffi.uint16+ '?val?'::
+$ffi.int32+ '?val?'::
+$ffi.uint32+ '?val?'::
+$ffi.dword+ '?val?'::
+$ffi.int64+ '?val?'::
+$ffi.uint64+ '?val?'::
+$ffi.char+ '?val?'::
+$ffi.uchar+ '?val?'::
+$ffi.short+ '?val?'::
+$ffi.ushort+ '?val?'::
+$ffi.int+ '?val?'::
+$ffi.uint+ '?val?'::
+$ffi.long+ '?val?'::
+$ffi.ulong+ '?val?'::
+$ffi.pointer+ '?val?'::
	Creates a new object which represents a C variable of a specific type. If no
	initial value is specified, the default is '0'.

[NOTE]
'ffi.char', 'ffi.uchar' and 'ffi.dword' are synonyms for 'ffi.int8',
'ffi.uint8' and 'ffi.uint32', respectively.

[NOTE]
To convert a 'ffi.char' to its 1-length string representation, use
'ffi.string at'.

+$ffi.void+::
	Creates a new dummy object, for use with 'ffi.function' against functions
	which return 'void'.

Object Operations
+++++++++++++++++
+$obj+ 'value'::
	Returns the decoded value of a C variable.

+$obj+ 'raw'::
	Returns the raw value of a C variable, as a binary buffer.

+$obj+ 'address'::
	Returns the address of a C variable (equivalent to prefixing a variable name
	with '&', in C).

[NOTE]
For pointers, 'address' returns a pointer to the pointer (e.g. a 'char **' for
strings).

+$obj+ 'size'::
	Returns the raw size of a C variable (equivalent to 'sizeof()').

Strings and Memory Operations
+++++++++++++++++++++++++++++
+$ffi.string+ 'at addr ?len?'::
	Reads the string at a given memory address. If no length is specified, data
	is read up to the first '\0' byte found.

[WARNING]
'ffi.string at' is memory-unsafe; if there is no '\0' byte at an accessible
offset after the given address, +szl+ will crash.

[TIP]
'ffi.string at' can be used as a C to +szl+ 'memcpy()'; read data is guaranteed
to be '\0'-terminated.

+$ffi.string+ 'copy obj'::
	Creates a C string with a given initial value.

+$ffi.cast+ 'addr type'::
	Reads a C variable at a given address and returns a new object. The type
	shall be one of 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32',
	'dword', 'int64', 'uint64', 'char', 'uchar', 'short', 'ushort', 'int',
	'uint', 'long', 'ulong' and 'pointer'.

[TIP]
Use 'ffi.cast' to dereference pointers.

Data Structures
+++++++++++++++
+$ffi.struct+ 'raw type...'::
	Creates a new 'struct', which can be optionally initialized by specifying
	its raw contents instead of an empty string.

+$struct+ 'member index'::
	Returns the value of a 'struct' member, as a new object.

Libraries
+++++++++
+$ffi.dlopen+ 'path'::
	Loads a shared object.

[NOTE]
To obtain the +szl+ executable handle, call 'ffi.dlopen' and pass an empty
string as the path (equivalent to 'dlopen()' with 'NULL').

+$lib+ 'handle'::
	Returns the handle (i.e. the return value of 'dlopen()') of a shared
	object.

+$lib+ 'dlsym name'::
	Returns the address of a symbol exported by a shared object.

Functions
+++++++++
+$ffi.function+ 'addr rtype ?type...?'::
	Wraps a C function with a +szl+ procedure. The return value type may be
	'void', in addition to the types recognized by 'ffi.cast'.

+$func+ 'ret ?arg...?'::
	Calls a C function. The return value and argument objects must be specified
	by address (e.g. '$obj address').

archive
^^^^^^^
The 'archive' extension is a +szl+ wrapper for
http://www.libarchive.org/[libarchive].

+$archive.open+ 'data'::
	Opens an archive.

+$archive+ 'list'::
	Lists files contained in an archive.

+$archive+ 'extract'::
	Extracts files contained in an archive to the working directory.

linenoise
^^^^^^^^^
The 'linenoise' extension provides command-line editing and history through
https://github.com/antirez/linenoise[linenoise].

+$linenoise.read+ 'prompt'::
	Displays a prompt and reads a line.

+$linenoise.add+ 'line'::
	Adds a line to history.

+$linenoise.save+ 'path'::
	Saves history to a file.

+$linenoise.load+ 'path'::
	Loads a previously saved history file.

ed25519
^^^^^^^
The 'ed25519' extension implements a public key security system, using
https://github.com/orlp/ed25519[Ed25519].

+$ed25519.keypair+::
	Generates a key pair and returns a list of two items: the first is the
	private key and the second is the public one.

+$ed25519.sign+ 'data priv pub'::
	Digitally-signs a buffer.

+$ed25519.verify+ 'data sig pub'::
	Verifies the digital signature of a buffer.

Best Practices
--------------
Efficiency
~~~~~~~~~~
[quote, 'Socrates']
Every action has its pleasures and its price.

1. Avoid unnecessary 'str.expand' or 'str.format' calls.
2. Avoid the wrapping of strings with braces, if they do not contain spaces.
3. Avoid the creation of redundant objects; it's OK and even recommended not
   to save the return value of a statement if you don't need it.
4. Avoid redundant statements, like 'return [foo]' instead of 'foo' at the end
   of a procedure. The extra procedure call ('return') is a waste of time.
5. When checking if a string is empty, avoid '$if [$> [$str.len $foo] 0]' and
   prefer '$if $foo'. The truth value of empty strings is false, so this saves
   two procedure calls.
6. Whenever possible, use local variables ('local') instead of globals
   ('global'). They get garbage collected earlier, so this results in reduced
   memory usage.
7. Always simplify logical expressions, to reduce the number of procedure calls.
   For example, '$!= $foo $bar' runs faster than '$! [$== $foo $bar]'.
8. When joining more than two objects, avoid multiple 'str.append' calls and use
   'str.join' instead.
9. 'str.append' does not create a new object and therefore it is more
   efficient for joining only two strings.
10. Always trim useless trailing whitespace in scripts (or use a text editor
    that takes care of this automatically), to speed up parsing.
11. Always store constant lists in named objects. For example, if you intend to
    run multiple 'for' loops with the same input (say, a series of words), store
    that input in an object. This way, the string representation of the object
    is split only once.
12. Use 'switch' instead of nested 'if' calls.

Error Handling
~~~~~~~~~~~~~~
For error handling, use the shorter and more manageable approach of early
'throw' and late 'except' -
--------------------------------------
$try {
	$f 1 2 3
	$g 4 5 6
	$h 7 8 9
	.
	.
	.
} except {
	$puts [$str.format {an error has occurred: {}} $_]
}
--------------------------------------
instead of boolean return values and a pyramid of nested checks, e.g.:
--------------------------------------
$if {[$f 1 2 3]} {
	$if {[$g 4 5 6]} {
		$if {[$h 7 8 9]} {
			.
			.
			.
		} else {
			$puts {h failed}
		}
	} else {
		$puts {g failed}
	}
} else {
	$puts {f failed}
}
--------------------------------------
This is highly beneficial, for several reasons:

- Error handling is implemented *using less statements*: one 'try' statement,
  instead of multiple 'if' calls.
- It is easy to deal with new potential failures introduced over time, as the
  'try' block gets bigger. In the 'if' approach, each error needs an additional
  'if'.
- The code is much easier to understand, because it's linear and left-aligned:
  there is only one level of identation.

Implementation
--------------
Overview
~~~~~~~~
+szl+ is implemented as a C (or more specifically, C99) library and targets
http://www.kernel.org/[Linux] distributions.

Objects
~~~~~~~
Each and every +szl+ object is represented by a +struct szl_obj+.

Call Stack
~~~~~~~~~~~
+szl+ always keeps track of two running procedure calls:

1. The currently running procedure, which changes every time a procedure is
   called
2. The _global procedure_: all objects accessible from any part of the
   script (for example, objects created outside of a procedure body) are
   represented internally as local objects of this special scope

Memory Management
~~~~~~~~~~~~~~~~~
+szl+ implements automatic garbage collection using manual reference counting.
Procedures always return a new reference, which may be the first reference of a
newly allocated object or an additional reference to an existing one.

When a procedure returns, its dictionary of local objects is garbage collected.
Procedures are always registered as global variables, so they get garbage
collected only upon termination of the interpreter.

Type System
~~~~~~~~~~~
Each +szl+ object may be represented internally using one or more of five
types:

1. String
2. Wide-character string
3. Integer
4. Floating-point integer
5. List
6. Code

Most +szl+ objects start their lifetime as 'UTF-8' strings. When a string is
passed to a procedure that performs a numeric operation, a numeric
representation is added to the passed object (i.e. so it has two
representations, textual and numeric). During string operations which require
character-based indexing (such as 'str.tail'), strings are decoded.

In addition, each statement is represented as a list object and multiple
statements (like the block passed to 'if') are represented as code objects,
which are lists of statements. When a code block is invoked more than once (e.g.
a loop body), its code representation and the list representation of each
statement are preserved to eliminate parsing overhead, while the procedure
call object is discarded to free its local objects.

Objects are hashed during comparison or lookup of local objects (which is done
by hash, since local objects are implemented using a dictionay). This way, the
lookup of objects is more efficient.

Booleans
^^^^^^^^
+szl+ has no "real" boolean type. Instead, '{}' and '0' are treated as false and
everything else is treated as true. Procedures that return boolean values return
the integers '1' and '0'.

Builtin Objects
~~~~~~~~~~~~~~~
Each +szl+ interpreter creates several singletons at initialization time:

1. '{}': all procedures that return an empty string return a new reference to
  the same object.
2. '{ }': a delimiter used during conversion between strings and lists.
3. Integers between '0' and '15': '1' and '0' also act as return values of
   boolean procedures like '=='.
4. '/': the value of 'path.sep'.
5. '_' and '@': the names of special objects.

This reduces memory consumption and improves efficiency, as these objects are
used very often.

Statement Execution
~~~~~~~~~~~~~~~~~~~
Statements are executed in blocks of multiple statements, like those passed to
'if' or 'for'.

Internally, each +szl+ statement returns two things:

1. An object (a new reference to a newly-created or existing object), which acts
   as return value upon success or as an error message upon failure
2. A status code, a member of 'enum szl_res'

The status code determines the direction of the script flow:

* 'SZL_OK': the status code returned by procedures upon success. The interpreter
  continues to the next statement in the block. For any status code other than
  'SZL_OK', the next statements in the block will not be executed.
* 'SZL_BREAK': the status code returned by 'break'. This status code is
  propagated until it reaches 'for', 'do' or 'while'. If the loop body returns
  'SZL_BREAK', the loop procedure stops and returns 'SZL_OK'.
* 'SZL_CONT': the status code returned by 'continue'. This status code is
  propagated until it reaches 'for', 'do' or 'while'. If the loop body returns
  'SZL_CONT', the loop procedure re-executes the loop body without propagating
  this status code.
* 'SZL_ERR': the status code returned by 'throw' or upon failure of a procedure
  (i.e. failure to open a file). This status code is always propagated. However,
  'try' returns 'SZL_OK' if the 'try' block returns 'SZL_ERR' and no other error
  condition was triggered.
* 'SZL_RET': the status code returned by 'return'. This status code is
  propagated until it reaches 'proc', which returns 'SZL_OK' if the procedure
  body returned 'SZL_RET'.
* 'SZL_EXIT': the status code returned by 'exit'. This status code is always
  propagated.

Extensions
~~~~~~~~~~
All +szl+ procedures are part of extensions.

Extensions may be either linked statically into the interpreter, or built as
separate shared objects that export a function of type 'szl_ext_init', with a
name in the form 'SZL_EXT_INIT_FUNC_NAME_FMT'. This function shall register the
procedures and objects provided by the extension using 'szl_new_ext()'.

Some trivial procedures (such as 'puts') are implemented in 'szl' blobs
evaluated by extensions at initialization time. They implement +szl+ procedures,
on top of more low-level procedures exposed by the C extensions.

Build System
~~~~~~~~~~~~
+szl+ is built using http://mesonbuild.com/[Meson].

API Documentation
~~~~~~~~~~~~~~~~~
The +szl+ API is documented using http://www.doxygen.org/[Doxygen].
