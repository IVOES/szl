szl
===
Dima Krasner <dima@dimakrasner.com>
:Author Initials: DK
:numbered:
:website: http://github.com/dimkr/szl

:toc:

Introduction
------------
+szl+ (pronounced "sizzle") is a scripting language heavily inspired by Tcl and
shell. It follows five design principles:

1. Less syntax: there should be only *one, obvious way* to achieve a certain
   effect, to make the language easier to learn
2. Minimal syntax is not enough for code clarity; it also has to be *consistent*
   and therefore *predictable*
- Everything is a string
- Every statement is a procedure call
3. Minimal standard library, but comprehensive and useful enough to allow the
   addition of more complex operations
4. One-liners are first-class citizens and *not* frowned upon
5. Good balance between performance and code size: the interpreter core should
   be as small as possible, while more high-level parts of the standard library
   are implemented as scripts; however, the interpreter should be efficient
   enough to achieve reasonable performance and the language should be designed
   to allow this

[quote, 'Vincent Van Gogh']
Great things are ... done by a series of small things brought together.

The +szl+ interpreter is designed as a library, exposes a high-level API and can
be easily embedded in other software projects.

The term "+szl+" refers to *both* the programming language and its official
interpreter, depending on the context.

This Document
-------------
This is a comprehensive manual, for the +szl+ user or for developers who wish to
extend +szl+ or integrate it into their projects.

[WARNING]
This manual may reflect a future state of +szl+.

Use Cases
~~~~~~~~~
+szl+ is especially useful when:

1. One needs a swiss knife, "shell on steroids" for automation or DevOps
   scripts, but shell scripting isn't powerful enough (because shell language
   lacks programming language features such as exceptions), while other
   languages are too powerful and require too much work to execute processes and
   read their output
2. One needs a balanced, not too low-level and not too high-level programming
   language for system development rapid prototyping
3. One needs a quick n' dirty way to call C functions, without having to do
   native development: +szl+ allows interfacing with C code and data types via
   scripts!
4. One needs an embedded interpreter in a big software project, used as a logic
   layer, high-level glue between components written in different languages or
   as a scripting engine for advanced users (for example, in a console window of
   an action game)
5. A complex task is very hard or impossible to accomplish using nothing but
   traditional *nix tools (such as +sh+, +nc+, +tar+ and +cut+)
6. One needs an extremely lightweight scripting language, for quick development
   of programs that run on underpowered hardware, such as cheap Wi-Fi routers
7. One wants to introduce non-technical people to programming, using an easy to
   learn scripting language with a simple syntax

History
~~~~~~~
+szl+ began its life as a pet project: a clean-room, partial re-implementation
of http://jim.tcl.tk/[jimtcl], for self-education purposes.

However, quickly enough, as more and more new ideas were translated into code,
+szl+ evolved into a much different beast.

Tutorial
--------
[quote, 'Friedrich Nietzsche']
The doer alone learneth.

Getting Started
~~~~~~~~~~~~~~~
Each and every +szl+ script is a text file which consists of lines in the
following form:

--------------------------------------
proc arg arg
--------------------------------------

Lines that begin with '#' are comments and ignored by the interpreter:

--------------------------------------
# this is a very useful script
proc arg arg
--------------------------------------

To run a script, run +szlsh+ (the +szl+ interpreter) in a console:

--------------------------------------
$ szlsh script.szl
--------------------------------------

Working with Variables
~~~~~~~~~~~~~~~~~~~~~~
Basically, each statement is a series of space-delimited tokens. The first
token, which is usually a verb, is the name of a procedure (think, _function_).
The procedure receives the rest of the tokens as arguments (input), does
something and returns an object (output). For example, in the following
statement, 'calc' receives '1', '+' and '2' as arguments and returns '3' as
output:

--------------------------------------
calc 1 + 2
--------------------------------------

[NOTE]
Some procedures do not receive any arguments.

Objects (sometimes referred to as variables) are identified by name and carry
values (such as text strings or numbers). To create a new object or change the
value of an existing one, use 'local':

--------------------------------------
local number 5
--------------------------------------

'local' receives the object name and its value. To query the value of an
existing object, prefix its name with '$', like this:

--------------------------------------
puts $number
--------------------------------------

'$number' will be expanded: the value of 'number' will be fetched and passed to
'puts' as its argument.

In +szl+, all objects (including numbers and even lists) are represented as
strings and +szl+ knows how to treat them, depending on the context. For
example, once two objects are passed to the 'calc' procedure receives as
arguments, they are treated as numbers.

When an object is no longer used, +szl+ will automatically free all resources
associated with it: that's "garbage collection".

Grouping
~~~~~~~~
Multi-word values should be grouped using braces:

--------------------------------------
local message {hello world}
--------------------------------------

In this example, 'local' accepts two arguments: 'message' and 'hello world'.

Some procedures (for example, 'if') accept +szl+ statements as their arguments.
For example, in the the following snippet (which prints 'ok'), 'puts ok' is an
argument of 'if':

--------------------------------------
if 1 {puts ok}
--------------------------------------

A block of multiple +szl+ statements passed as an argument can be also be laid
out like this:

--------------------------------------
if 1 {
	puts hello
	puts world
}
--------------------------------------

[NOTE]
A block can be idented using either spaces, tabs or both. Whitespace at the
beginning or end of statements is ignored.

Using Return Values
~~~~~~~~~~~~~~~~~~~
To obtain the return value of a procedure, wrap the statement that calls it with
brackets. A statement enclosed in brackets is executed and replaced with its
return value.

For example, the following example executes 'calc 1 + 2.5' and stores the return
value of this procedure in a variable, 'sum':

--------------------------------------
local sum [calc 1 + 2.5]
--------------------------------------

[NOTE]
Every procedure has a return value. If a procedure does not specify a return
value, it returns an empty string.

[TIP]
The return value of the previously called procedure is stored in the special
variable '_', in the calling scope.

Both braces and brackets may be nested, to form more complex logic:

--------------------------------------
local sum [calc [str.length {hello world}] - 3]
--------------------------------------

Special Characters
~~~~~~~~~~~~~~~~~~
Special characters such as line breaks can be used in object declarations, using
a backslash ('\') and 'str.expand':

--------------------------------------
local tabs [str.expand \t\t]
--------------------------------------

Formatting Strings
~~~~~~~~~~~~~~~~~~
To form more complex strings, such as user-friendly messages, use 'str.format':

--------------------------------------
puts [str.format {the sum of {} and {} is {}} 3 4 [calc 3 + 4]]
--------------------------------------

'str.format' accepts a format string (or, a template) and replaces
occurrences of '{}' with the arguments that follow.

Declaring Procedures
~~~~~~~~~~~~~~~~~~~~
+szl+ can be extended with additional procedures, using 'proc'. The following
example defines a procedure called 'print_hello' and calls it:

--------------------------------------
proc print_hello {
	puts hello
}

print_hello
--------------------------------------

Procedure arguments are accessible using variables named '1', '2' and so on. The
following procedure prints its first argument ('hello'):

--------------------------------------
proc print_something {
	puts $1
}

print_something hello
--------------------------------------

The number of arguments passed to a function is accessible through the '#'
variable:

--------------------------------------
proc print_argument_count {
	puts [str.format {received {} arguments} $#]
}

print_argument_count a b c
--------------------------------------

In addition, a procedure may access its list of arguments, via the special '@'
variable:

--------------------------------------
proc print_statement {
	puts [str.format {invoked with arguments: {}} $@]
}

print_statement a b {c d} e f {g h}
--------------------------------------

The return value of a procedure is either:

1. The value set by to 'return', if 'return' was called within the procedure
   body ...
2. **or** the return value of the last statement of the procedure body, if
   'return' was not called

For example, the following functions are identical, functionality-wise:
--------------------------------------
proc foo {
	puts {before check}
	test 1 == 2
}

proc bar {
	puts {before check}
	return [test 1 == 2]
	puts {after check}
}
--------------------------------------

Using Extensions
~~~~~~~~~~~~~~~~
To obtain access to more procedures, +szl+ provides an extensions mechanism. For
example, to be able to compress files using the 'zlib.gzip' procedure, the
'zlib' extension should be loaded:

--------------------------------------
load zlib
--------------------------------------

Using Modules
~~~~~~~~~~~~~
In addition, large +szl+ scripts can be split into several files (or "modules"),
for easier maintenance and the ability to share parts (like helper procedures)
between projects. For example, utility procedures can be put in 'util.szl'.
Then, 'source' can be used to execute this file through the script body:

--------------------------------------
source util.szl
--------------------------------------

Summary
~~~~~~~
The entire syntax of +szl+ is based on four types of expressions:

1. Single-word strings
2. Strings wrapped with braces: multi-word strings
3. Strings that begin with '$' followed by a variable name and whitespace:
   variable values
4. Strings wrapped with brackets: procedure calls

Standard Library
----------------
Builtin Procedures
~~~~~~~~~~~~~~~~~~
Objects
^^^^^^^
+echo+ 'obj'::
	Returns 'obj'.

--------------------------------------
test [echo 5] == 5
--------------------------------------

+get+ 'name'::
	Returns the variable named 'name'.

--------------------------------------
local a 5
test [get a] == 5
--------------------------------------

Variables
+++++++++
+local+ 'name val'::
	Creates a new variable in the local scope.

[TIP]
'local' returns the variable value, which is useful for one-liners (for example,
when one wishes to create a new variable and pass its value to another
procedure).

+export+ 'name ?val?'::
	Creates a local variable in the calling scope. If no value is specified, the
	value of the local variable with the same name is used as fallback.

--------------------------------------
proc check_if_bigger_than_ten {
	local bigger 0
	if [test $1 > 10] {export bigger 1}
	puts $bigger
}

check_if_bigger_than_ten 12
--------------------------------------

+global+ 'name val'::
	Similar to 'local', but creates the new variable in the global scope. The
	variable will be accessible from all procedures.

[NOTE]
If a procedure uses 'local' to define a local variable with the same name as
a previously defined global variable, attempts to obtain the variable value from
within the procedure will refer to the local variable.

+locals+::
	Returns a unique list of objects in the local scope.

+globals+::
	Returns a unique list of objects in the global scope.

String Operations
+++++++++++++++++
+str.length+ 'str'::
	Returns the length of a string.

+str.count+ 'str sub'::
	Returns the number of occurrences of 'sub' in 'str'.

+str.range+ 'str start end'::
	Returns the characters in a string, between zero-based indices 'start' and
	'end'.

+str.in+ 'str sub'::
	Returns '1' if 'sub' is a substring of 'str', otherwise '0'.

+str.tail+ 'str ?count?'::
	Returns the last characters of a string. If the number of characters is not
	specified, the default is '1'.

+str.append+ 'name str'::
	Appends a string to an existing str.

+str.split+ 'str delim'::
	Splits a string consisting of tokens separated by a delimiter.

+str.join+ 'delim str str ?...?'::
	Joins multiple strings, with a delimiter (which may be an empty string).

[NOTE]
'str.join' is the most efficient way to concatenate more than two strings.

+str.expand+ 'str'::
	Expands escape sequences in a string: '\0', '\\', '\n', '\t', '\r' and
	hexadecimal numbers in '\x' notation (e.g. '\xff').

--------------------------------------
puts [str.expand {this is a\n\tmulti-line strin\x67}]
--------------------------------------

+str.format+ 'fmt obj...'::
	Receives a format string and replaces all occurrences of '{}' with their
	values.

--------------------------------------
puts [str.format {the length of "{}" is {}} abcd [str.length abcd]]
--------------------------------------

+str.rtrim+ 'str'::
	Removes whitespace at the end of a string.

+str.ltrim+ 'str'::
	Removes whitespace at the beginning of a string.

+str.trim+ 'str'::
	Removes whitespace at both ends of a string.

List Operations
+++++++++++++++
+list.length+ 'list'::
	Returns the number of items in a list.

+list.range+ 'list start end'::
	Returns the items in a list, between zero-based indices 'start' and 'end'.

--------------------------------------
local fruits {apple orange pear}
puts [str.format {the first two fruits are: {}} [list.range $fruits 0 1]]
--------------------------------------

+list.in+ 'list item'::
	Returns '1' if 'item' is an item of 'list', otherwise '0'.

--------------------------------------
local fruits {apple orange pear}
puts [list.in $fruits orange]
puts [list.in $fruits melon]
--------------------------------------

+list.append+ 'name item'::
	Appends an object to a list.

--------------------------------------
local fruits {apple orange}
list.append fruits pear
puts $fruits
--------------------------------------

+list.join+ 'delim list'::
	Joins the items of a list to form a string.

--------------------------------------
puts [str.format {three fruits: {}} [list.join , {apple orange pear}]]
--------------------------------------

+list.extend+ 'name list'::
	Adds all items in a list to an existing list.

--------------------------------------
local fruits {apple orange}
list.extend fruits {pear banana}
puts $fruits
--------------------------------------

+list.zip+ 'list list...'::
	Returns a list of lists, each containing the 'n'-th elements of given lists
	of the same length.

--------------------------------------
for pair [list.zip {apple orange pear} {red orange green}] {
	puts [str.format {{}s are {}} [list.index $pair 0] [list.index $pair 1]]
}
--------------------------------------

+list.sum+ 'list list...'::
	Returns a list containing the items of given lists.

--------------------------------------
local fruits [list.sum {apple orange} pear]
--------------------------------------

+list.reverse+ 'list'::
	Returns all items in a list, in reverse order.

+list.index+ 'list index'::
	Returns the list item at the zero-based position 'index'.

+range+ '?start? end'::
	Returns a list of integers in a given range. The maximum is non-inclusive.
	If no minimum is specified, the range starts at '0'.

--------------------------------------
for i [range 1 11] {puts $i}
--------------------------------------

Arithmetic and Logical Operations
+++++++++++++++++++++++++++++++++
+calc+ 'm op n'::
	Performs an arithmetic operation on two numbers. The operation may be '+',
	'-', '*', '/' or '%'.

+true+::
	Returns '1'.

+false+::
	Returns '0'.

+test+ 'obj op obj'::
	Compares two objects and returns '1' if the specified condition is true,
	otherwise '0'. The comparison operation may be '==', '!=', '<', '>', '\<=',
	'>=', '&&', '||' or '^'.

--------------------------------------
if [test [test [calc 1 + 1] == 2] && [test [calc 2 + 2] == 4]] {puts yes}
--------------------------------------

+not+ 'cond'::
	Returns '0' if a condition is true, otherwise '1'.

+any+ 'cond...'::
	Returns '1' if at least one condition is true, otherwise '0'.

+all+ 'cond...'::
	Returns '0' if at least one condition is false, otherwise '1'.

Procedures
^^^^^^^^^^
+proc+ 'name exp'::
	Defines a new procedure.

+return+ '?obj?'::
	Stops the execution of a procedure and sets its return value. If no return
	value is specified, the procedure returns an empty string.

+stack+ '?lim?'::
	Returns all statements or only the bottom 'lim' statements, in the stack of
	procedure calls that lead to the the 'stack' call.

+load+ 'name'::
	Loads a 'szl' extension, to make additional procedures available.

Flow Control
^^^^^^^^^^^^
+if+ 'cond exp ?else exp?'::
	Conditionally runs a block.

+switch+ 'obj val exp val exp...'::
	For each pair of a value and a block, compares an object to the value and
	runs the block and stops if they are equal, or if the value is '*'.

--------------------------------------
switch [calc 1 + 2] 2 {
	puts {it is 2}
} 3 {
	puts {it is 3}
} 4 {
	puts {it is 4}
} * {
	puts {unknown result}
}
--------------------------------------

+while+ 'cond exp'::
	Runs a block as long as a condition is met.

+do+ 'exp while cond'::
	Similar to 'while', but checks the condition after the first execution of
	the loop body.

+map+ 'names list exp'::
	For each series of items in a list, runs a block with local variables that
	specify the items and returns a list of the block return values.

--------------------------------------
puts [map {a b} {1 1 1 2 1 3 1 4} {calc $a + $b}]
--------------------------------------

[TIP]
'map' is particularly useful for elegant one-liners, at the cost of memory
usage (since the block return values are collected in a new list).

+for+ 'name list exp'::
	Same as 'map', but discards the block return values.

--------------------------------------
for {a b} {1 2 3 4 5 6 7 8} {
	puts [str.format {a is {} and b is {}} $a $b]
}
--------------------------------------

+break+::
	Stops the execution of a loop.

+continue+::
	Stops the execution of a loop body and continues to the next iteration.

+exit+ '?obj?'::
	Stops the execution of the script and optionally, sets its return value.

+sleep+ 'sec'::
	Suspends the script execution for a given interval, specified in seconds.
	The interval may be a floating-point number (e.g. '4.5').

+eval+ 'exp'::
	Evaluates a +szl+ expression in the current scope.

+source+ 'path'::
	Execute a 'szl' script in the global scope.

Exceptions
++++++++++
+try+ 'exp ?except exp? ?finally exp?'::
	Runs an block. Optionally, if a statement failed, jumps to a second, error
	handling block. Unconditionally, a third (usually, cleanup code) block is
	executed afterwards. The error handling block can access the error string
	via '_', like this:

--------------------------------------
try {
	puts
} except {
	puts [str.format {caught an error: {}} $_]
} finally {
	puts {Always executed}
}
--------------------------------------

[TIP]
Any set of statements can be wrapped with a 'try' block without a matching
'except', to silently ignore errors.

+throw+ '?msg?'::
	Triggers an error condition and optionally specifies an explanation. The
	error condition may be caught by a 'try' call.

--------------------------------------
try {
	throw {some error description}
} except {
	puts [str.format {caught an error: {}} $_]
}
--------------------------------------

Interpreters
++++++++++++
+szl.interp+::
	Creates a new +szl+ interpreter.

+$interp+ 'eval exp'::
	Evaluates a +szl+ expression in an interpreter.

+szl.shell+::
	Runs an interactive +szl+ interpreter.

I/O
^^^
+puts+ 'msg'::
	Prints an object to standard output. If the object does not end with a line
	break ('\n'), a line break character is appended.

+null+::
	Creates a fake, empty file. Every attempt to read from the file returns an
	empty string and all data written to it is discarded.

+$stdin+::
+$stdout+::
+$stderr+::
	Streams in the global scope, representing standard input, output and error
	output, respectively.

File System
^^^^^^^^^^^
+$path.sep+::
	The separator between path components.

+path.join+ 'str...'::
	Joins path components.

--------------------------------------
local path [path.join .. something.txt]
--------------------------------------

[TIP]
To join path components in a portable way, use 'path.join'.

+path.exists+ 'path'::
	Checks whether a file exists.

+file.size+ 'path'::
	Returns the size of a file.

+file.delete+ 'path'::
	Deletes a file.

+file.lock+ 'path'::
	Creates a lock file, locks it and returns a lock file object.

[NOTE]
If another process locks the file, 'file.lock' will block until it is released.

+$lock+ 'unlock'::
	Unlocks a lock file.

[NOTE]
Leftover lock files are unlocked automatically, during garbage collection.

+file.locked+ 'path'::
	Checks whether a lock file is locked.

+dir.create+ 'path'::
	Creates a directory.

+dir.delete+ 'path'::
	Deletes an empty directory.

+dir.rdelete+ 'path'::
	Recursively deletes the contents of a directory and the directory itself.

+cd+ 'path'::
	Changes the working directory.

File Operations
+++++++++++++++
+open+ 'path mode'::
	Opens a file and returns a stream object. 'mode' is 'fputs()'-style: 'r',
	'w', 'a', 'r+', 'w+' or 'a+' (see 'man fputs' for the meaning of each mode).
	By default, reading and writing is line-buffered.

[NOTE]
'mode' can be suffixed with 'b' to enable full buffering instead of line-based
buffering, which improves efficiency with binary files.

[NOTE]
'mode' can be suffixed with 'u' to disable buffering, which improves efficiency
when 'read' is called only once (for example, when the entire file is read at
once).

+$stream+ 'read ?len?'::
	Reads a 'len' bytes from a stream, or its entire contents. If the stream is
	non-blocking and less than 'len' bytes are available for reading without
	waiting, that will be the number of bytes returned.

+$stream+ 'write str'::
	Writes a string to a stream. If the stream is non-blocking and only a part
	of the string could be written without waiting, the procedure will return
	the number of bytes written.

[NOTE]
Since writing operations on files may be buffered to improve efficiency, data
passed to 'write' is not guaranteed to be written to disk immediately. To flush
queued data to disk, call 'flush'.

+$stream+ 'unblock'::
	Enables non-blocking operation on a stream.

+$stream+ 'flush'::
	Flushes the output buffer of a file.

+$stream+ 'handle'::
	Returns an opaque value (an integer) that represents an open file, suitable
	for 'poll'.

+$stream+ 'close'::
	Closes a file.

[NOTE]
'close' is called automatically during garbage collection. In many cases, an
implicit 'close' call is redundant and trivial file operations can be
implemented as one-liners:

--------------------------------------
local content [[open /etc/hosts ru] read]
--------------------------------------

File Handle Operations
++++++++++++++++++++++
+fdopen+ 'handle'::
	Re-opens an existing stream by its handle.

[WARNING]
Streams created using 'fdopen' do not carry the state (for example, queued
unwritten data) of the original streams. To avoid corruption of written data,
call 'flush' before reusing a file handle.

[WARNING]
Streams created using 'fdopen' share the same underlying handle as the original
streams: when a stream is closed, all streams that share its handle are
invalidated.

[WARNING]
Writing to a single file via multiple streams simultaneously is likely to result
in data corruption.

+dup+ 'handle'::
	Duplicates an existing handle, to allow the creation of a new stream which
	shares the same underlying handle as an existing one, but without affecting
	the original stream.

Sockets
^^^^^^^
+socket+ 'type host service'::
	Creates a new TCP or UDP socket. Client sockets ('stream.client' and
	'dgram.client') are connected to 'host:service', while server sockets
	('stream.server' and 'dgram.server') are bound to 'host:service'.

[NOTE]
In server mode, if 'service' is an empty string, the socket is bound to the
wildcard address.

[TIP]
Sockets behave very much like files (e.g. they provide 'read' and 'write').
During testing, sockets can be easily swapped with files to simulate incoming
data.

+$socket+ 'accept'::
	Waits for a client to connect to a 'stream.server' socket and returns a new
	socket.

Socket I/O Multiplexing
+++++++++++++++++++++++
+poll.create+::
	Creates a new set of polled sockets and timers.

+$poll+ 'add handle event...'::
	Adds a handle to a set and enables monitoring of specific events. Currently
	supported event types are 'in' (data available for immediate 'read') and
	'out' (ability to 'write' without waiting).

+$poll+ 'remove handle'::
	Removes a handle from a set.

+$poll+ 'wait lim'::
	Waits for up to 'lim' socket or timer events and returns three lists of
	handles: those ready for reading, writing or error handling.

+timer+ 'interval'::
	Creates a non-readable stream, which triggers an 'in' event after 'interval'
	seconds.

Processes
^^^^^^^^^
+getpid+::
	Returns the process ID of the +szl+ interpreter.

+exec+ 'cmd'::
	Runs a shell command, waits for it to terminate and returns its output. In
	addition, the process exit code is put in the special variable '?', in the
	scope of the calling procedure.

[TIP]
'exec' passes 'cmd' to the default shell, so 'cmd' may rely on shell features
such as redirection (e.g. '2>&1'):
--------------------------------------
exec {uname -a 2>&1}
local os $_
puts $?
--------------------------------------

Signals
^^^^^^^
+signal.block+ 'sig...'::
	Blocks a list of signals and returns a signal mask object. The signals may
	be 'term', 'int', 'usr1' or 'usr2'.

+$mask+ 'check'::
	Checks whether a signal blocked by a signal mask has been received and
	blocked.

Environment
^^^^^^^^^^^
+env.get+ 'name'::
	Returns the value of an environment variable.

+$env.ver+::
	The +szl+ version.

+$env.intmax+::
	The maximum value of a C 'int', on the hardware architecture +szl+ runs on.
	This value is useful as an upper limit for input sanity checks (for example,
	the maximum size of a file specified by the user).

Extensions
~~~~~~~~~~
Compression
^^^^^^^^^^^
zlib
++++
The 'zlib' extension is a +szl+ wrapper for http://zlib.net/[zlib], a general
purpose data compression library.

+zlib.crc32+ 'str ?init?'::
	Returns the CRC32 checksum of a buffer. Optionally, an initial value may be
	specified; this is most useful for calculating the checksum of chunked data
	read from a stream (for instance, a pipe).

+zlib.deflate+ 'str ?level?'::
	Compresses a buffer and outputs a raw, Deflate-compressed stream.
	Optionally, a compression level ('1'-'9') may be specified to choose the
	desired speed vs. compression rate ratio.

+zlib.inflate+ 'str ?bufsiz?'::
	Decompresses a raw, Deflate-compressed stream. When the uncompressed data
	size is known and specified, memory allocation is *more efficient*.
	Otherwise, decomperssion is chunked and therefore slower.

+zlib.gzip+ 'str ?level?'::
	Compresses a buffer and adds a gzip header.

+zlib.gunzip+ 'str ?bufsiz?'::
	Decompresses a gzip-compressed buffer. Decompression is chunked, with a
	default, *small* buffer size of 64K which guarantees lower memory
	footprint at the cost of speed. It is *highly recommended* to use a bigger
	size, on systems without a severe memory constraint.

lzfse
+++++
The 'lzfse' extension is a +szl+ wrapper for
https://github.com/lzfse/lzfse/[lzfse], a data compression library.

+lzfse.compress+ 'str'::
	Compresses a buffer.

+lzfse.decompress+ 'str'::
	Decompresses a buffer.

Network
^^^^^^^
tls
+++
The 'tls' extension implements secure, Transport Layer Security (TLS) wrapped
TCP sockets, through http://www.openssl.org/[OpenSSL] or a compatible library
such as http://www.libressl.org/[LibreSSL].

+tls.connect+ 'handle'::
+tls.accept+ 'handle cert priv'::
	Performs TLS handshake via an existing, connected socket and returns a new
	stream.

curl
++++
The 'curl' extension implements file download via multiple protocols, through
https://curl.haxx.se/[cURL].

+curl.encode+ 'str'::
	URL-encodes a string.

+curl.get+ 'url path...'::
	Downloads multiple files in parallel.

http
++++
The 'http' extension is a high-level interface for sending HTTP requests, mostly
useful for working with REST APIs.

+http.get+ 'host port tls url params'::
	Sends a 'GET' request to 'host:port/url' with 'params'. If 'tls' is true,
	the request is sent over HTTPS. 'params' should be a dictionary that maps
	parameter names to their values. The return value is a list of two items:
	the HTTP status code and the response body.

--------------------------------------
load http

local params [dict.new]
dict.set params a {123 456}
dict.set params b 789

puts [list.index [http.get httpbin.org 443 1 /get $params] 1]
--------------------------------------

+http.post+ 'host port tls url params'::
	Similar to 'http.get', but sends a 'POST' request instead.

+$http.codes+::
	A dictionary that maps HTTP status codes (e.g. '200') to their textual
	representation (e.g. 'ok').

dict
^^^^
The 'dict' extension is a slow, trivial +szl+ implementation of associative
arrays on top of lists and 'zlib.crc32'.

+dict.new+ ?k v...?::
	Creates a new dictionary. If no initial contents are specified, the
	dictionary will be empty.

+dict.items+ 'dict'::
	Returns a list of all keys and values in a dictionary.

+dict.set+ 'name k v'::
	Sets the dictionary value associated with a key.

+dict.get+ 'dict k ?v?'::
	Returns the dictionary value associated with a key. If the key is missing
	and no fallback value is specified, an exception is thrown.

test
^^^^
The 'test' extension provides test helpers.

+test.run+ 'desc throws exp result'::
	Runs 'exp' and compares its result or the error it throws (depending on the
	'throws' flag) to 'result'.

ffi
^^^
The 'ffi' extension is a +szl+ wrapper for
http://sourceware.org/libffi/[libffi] and provides an interface to C data types,
raw memory operations and C function calls through +szl+ scripts.

Data Types
++++++++++
+ffi.int8+ '?val?'::
+ffi.uint8+ '?val?'::
+ffi.int16+ '?val?'::
+ffi.uint16+ '?val?'::
+ffi.int32+ '?val?'::
+ffi.uint32+ '?val?'::
+ffi.dword+ '?val?'::
+ffi.int64+ '?val?'::
+ffi.uint64+ '?val?'::
+ffi.char+ '?val?'::
+ffi.uchar+ '?val?'::
+ffi.short+ '?val?'::
+ffi.ushort+ '?val?'::
+ffi.int+ '?val?'::
+ffi.uint+ '?val?'::
+ffi.long+ '?val?'::
+ffi.ulong+ '?val?'::
+ffi.pointer+ '?val?'::
	Creates a new object which represents a C variable of a specific type. If no
	initial value is specified, the default is '0'.

[NOTE]
'ffi.char', 'ffi.uchar' and 'ffi.dword' are synonyms for 'ffi.int8',
'ffi.uint8' and 'ffi.uint32', respectively.

[NOTE]
To convert a 'ffi.char' to its 1-length string representation, use
'ffi.string at'.

+ffi.void+::
	Creates a new dummy object, for use with 'ffi.function' against functions
	which return 'void'.

Object Operations
+++++++++++++++++
+$obj+ 'value'::
	Returns the decoded value of a C variable.

+$obj+ 'raw'::
	Returns the raw value of a C variable, as a binary buffer.

+$obj+ 'address'::
	Returns the address of a C variable (equivalent to prefixing a variable name
	with '&', in C).

[NOTE]
For pointers, 'address' returns a pointer to the pointer (e.g. a 'char **' for
strings).

+$obj+ 'size'::
	Returns the raw size of a C variable (equivalent to 'sizeof()').

Strings and Memory Operations
+++++++++++++++++++++++++++++
+ffi.string+ 'at addr ?len?'::
	Reads the string at a given memory address. If no length is specified, data
	is read up to the first '\0' byte found.

[WARNING]
'ffi.string at' is memory-unsafe; if there is no '\0' byte at an accessible
offset after the given address, +szl+ will crash.

[TIP]
'ffi.string at' can be used as a C to +szl+ 'memcpy()'; read data is guaranteed
to be '\0'-terminated.

+ffi.string+ 'copy obj'::
	Creates a C string with a given initial value.

+ffi.cast+ 'addr type'::
	Reads a C variable at a given address and returns a new variable object. The
	type shall be one of 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32',
	'dword', 'int64', 'uint64', 'char', 'uchar', 'short', 'ushort', 'int',
	'uint', 'long', 'ulong' and 'pointer'.

[TIP]
Use 'ffi.cast' to dereference pointers.

Data Structures
+++++++++++++++
+ffi.struct+ 'raw type...'::
	Creates a new 'struct', which can be optionally initialized by specifying
	its raw contents instead of an empty string.

+$struct+ 'member index'::
	Returns the value of a 'struct' member, as a new variable object.

Libraries
+++++++++
+ffi.dlopen+ 'path'::
	Loads a shared object.

[NOTE]
To obtain the +szl+ executable handle, call 'ffi.dlopen' and pass an empty
string as the path (equivalent to 'dlopen()' with 'NULL').

+$lib+ 'handle'::
	Returns the handle (i.e. the return value of 'dlopen()') of a shared
	object.

+$lib+ 'dlsym name'::
	Returns the address of a symbol exported by a shared object.

Functions
+++++++++
+ffi.function+ 'addr rtype ?type...?'::
	Wraps a C function with a +szl+ procedure. The return value type may be
	'void', in addition to the types recognized by 'ffi.cast'.

+$func+ 'ret ?arg...?'::
	Calls a C function. The return value and argument objects must be specified
	by address (e.g. '$obj address').

archive
^^^^^^^
The 'archive' extension is a +szl+ wrapper for
http://www.libarchive.org/[libarchive].

+archive.open+ 'data'::
	Opens an archive.

+$archive+ 'list'::
	Lists files contained in an archive.

+$archive+ 'extract'::
	Extracts files contained in an archive to the working directory.

linenoise
^^^^^^^^^
The 'linenoise' extension provides command-line editing and history through
https://github.com/antirez/linenoise[linenoise].

+linenoise.read+ 'prompt'::
	Displays a prompt and reads a line.

+linenoise.add+ 'line'::
	Adds a line to history.

+linenoise.save+ 'path'::
	Saves history to a file.

+linenoise.load+ 'path'::
	Loads a previously saved history file.

ed25519
^^^^^^^
The 'ed25519' extension implements a public key security system, using
https://github.com/orlp/ed25519[Ed25519].

+ed25519.keypair+::
	Generates a key pair and returns a list of two items: the first is the
	private key and the second is the public one.

+ed25519.sign+ 'data priv pub'::
	Digitally-signs a buffer.

+ed25519.verify+ 'data sig pub'::
	Verifies the digital signature of a buffer.

Best Practices
--------------
Efficiency
~~~~~~~~~~
[quote, 'Socrates']
Every action has its pleasures and its price.

1. Avoid unnecessary 'str.expand' or 'str.format' calls.
2. Avoid the wrapping of strings with braces, if they do not contain spaces.
3. Avoid the creation of redundant variables; it's OK and even recommended not
   to save the return value of a statement if you don't need it.
4. Avoid redundant statements, like 'return [foo]' instead of 'foo' at the end
   of a procedure. The extra procedure call ('return') is a waste of time.
5. Whenever possible, use local variables ('local') instead of globals
   ('global').
   They get garbage collected earlier, so this results in reduced memory usage.
6. Always simplify logical expressions, to reduce the number of procedure calls.
   For example, 'test $foo != $bar' runs faster than 'not [test $foo == $bar]'.
7. When joining more than two objects, avoid multiple 'str.append' calls and use
   'str.join' instead.
8. 'str.append' does not create a new object and therefore it is more
   efficient for joining only two strings.
9. Always trim useless trailing whitespace in scripts (or use a text editor that
   takes care of this automatically), to speed up parsing.
10. Always store constant lists in variables. For example, if you intend to run
    multiple 'for' loops with the same input (say, a series of words), store
    that input in a variable. This way, the string representation of the object
    is split only once.
11. Use 'switch' instead of nested 'if' calls.
12. Use '1' as the condition of infinite 'while' or 'do' loops. The evaluation
    of '[true]' is slower than the evaluation of '1', due to the extra procedure
    call involved.

Error Handling
~~~~~~~~~~~~~~
For error handling, use the shorter and more manageable approach of early
'throw' and late 'except' -
--------------------------------------
try {
	f 1 2 3
	g 4 5 6
	h 7 8 9
	.
	.
	.
} except {
	puts [str.format {an error has occurred: {}} $_]
}
--------------------------------------
instead of boolean return values and a pyramid of nested checks, e.g.:
--------------------------------------
if {[f 1 2 3]} {
	if {[g 4 5 6]} {
		if {[h 7 8 9]} {
			.
			.
			.
		} else {
			puts {h failed}
		}
	} else {
		puts {g failed}
	}
} else {
	puts {f failed}
}
--------------------------------------
This is highly beneficial, for several reasons:

- Error handling is implemented *using less statements*: one 'try' statement,
  instead of multiple 'if' calls.
- It is easy to deal with new potential failures introduced over time, as the
  'try' block gets bigger. In the 'if' approach, each error needs an additional
  'if'.
- The code is much easier to understand, because it's linear and left-aligned:
  there is only one level of identation.

Implementation
--------------
Overview
~~~~~~~~
+szl+ is implemented as a C (or more specifically, C99) library and targets
http://www.kernel.org/[Linux] distributions.

Objects
~~~~~~~
Each and every +szl+ variable or procedure is represented by a +struct szl_obj+.

Call Stack
~~~~~~~~~~~
+szl+ always keeps track of two running procedure calls:

1. The currently running procedure, which changes every time a procedure is
   called
2. The _global procedure_: all local objects accessible from any part of the
   script (procedures and variables set directly in the script body, not inside
   a procedure body) are represented internally as local variables of this
   special, non-callable, so-called _global procedure_

Memory Management
~~~~~~~~~~~~~~~~~
+szl+ implements automatic garbage collection using manual reference counting.
Procedures always return a new reference, which may be the first reference of a
newly allocated object or an additional reference to an existing one.

When a procedure returns, its local variables are garbage collected. Procedures
are always registered as global variables, so they get garbage collected only
upon termination of the interpreter.

Type System
~~~~~~~~~~~
Each +szl+ object may be represented internally using one or more of seven
types:

1. String
2. Integer
3. Floating-point integer
4. Boolean
5. List
6. Procedure
7. Procedure call
8. Hash

Most +szl+ objects start their lifetime as strings. When a string is passed to a
procedure that performs a numeric operation, a numeric representation is added
to the passed object (i.e. so it has two representations, textual and numeric).
In similar fashion, objects are assigned a truth value once they are passed to a
procedure that performs a logical operation.

In addition, a procedure call is represented as a list object containing the
statement (the procedure name, plus the value of '@') and a procedure call
object, which holds local variables. When a procedure is invoked more than once
(e.g. inside a 'for' block), the list representation of the statement is
preserved to eliminate parsing overhead, while the procedure call object is
discarded to free its local variables.

Objects gain a hash representation during comparison or lookup of local
variables (which is done by hash). This way, the lookup of objects (i.e. the
procedure object associated with the name of a procedure called inside the body
of a loop) is more efficient.

Booleans
^^^^^^^^
+szl+ has no "real" boolean type. Insead, '{}', '"0"' and '0' are treated as
false and everything else is treated as true. Procedures that return boolean
values return the integers '1' and '0'.

Builtin Objects
~~~~~~~~~~~~~~~
Each +szl+ interpreter creates four singletons at initialization time:

1. '{}'
2. '{ }'
3. '0'
4. '1'

All procedures that return an empty string return a new reference to the same
object. Similarily, all procedures that return '0' or '1' (most notably, boolean
procedures like 'test') use the same objects, instead of creating new, identical
objects. The space singleton is used by 'range'. This reduces memory consumption
and improves efficiency, as these return values are very common.

In addition, 'null' always returns the same object since it carries no state.

Statement Execution
~~~~~~~~~~~~~~~~~~~
Internally, each +szl+ statement that is executed returns two things:

1. A status code, member of 'enum szl_res'
2. An object (a new reference to a newly-created or existing object), which acts
   as return value upon success or as an error message upon failure

The status code determines the direction of the script flow:

* 'SZL_OK': business as usual; the interpreter will continue to the next
  statement.
* 'SZL_ERR': the interpreter will not execute the next statement; the current
  statement's return value (typically, an error string describing why it
  failed) will be used as the return value of the entire block and the error
  condition will be reported to the caller.
* 'SZL_BREAK': the interpreter will halt execution of statements in the current
  block.
* 'SZL_CONT': instead of executing the next statement in the loop body, the
  interpreter will continue to the next iteration.
* 'SZL_RET': the interpreter will stop the execution of statements in the
  current block and propagate the return value until it reaches a +szl+
  procedure.
* 'SZL_EXIT': the interpreter will stop the execution of statements and
  propagate the return value until the script execution stops.

'break' and 'continue' are empty procedures that only return a status code
('SZL_BREAK' and 'SZL_CONT', respectively). 'throw', 'return' and 'exit' return
'SZL_BREAK', 'SZL_RET' and 'SZL_EXIT', respectively, but also set the return
value.

Extensions
~~~~~~~~~~
All +szl+ procedures are part of extensions.

Extensions may be either linked statically into the interpreter, or built as
separate shared objects that export a function of type 'szl_ext_init', with a
name in the form 'SZL_EXT_INIT_FUNC_NAME_FMT'. This function shall register the
procedures and objects provided by the extension using 'szl_new_proc()'.

Some trivial procedures (such as 'puts') are implemented in 'szl' blobs
evaluated by extensions at initialization time (e.g. 'szl_str.szl'). They
implement +szl+ procedures, on top of more low-level procedures exposed by the C
extensions. Some of these low-level C procedures are considered implementation
details and their name is prefixed with an underscore (e.g. '_io.fdopen').

Build System
~~~~~~~~~~~~
+szl+ is built using https://www.gnu.org/software/make/[GNU Make].

The variables 'BUILTIN_EXT_NAMES' and 'EXTERNAL_EXT_NAMES' control which
extensions are built into +szlsh+ and loaded by default and which ones are built
as external libraries loaded via 'load'.

API Documentation
~~~~~~~~~~~~~~~~~
The +szl+ API is documented using http://www.doxygen.org/[Doxygen]. Run 'make
api_doc' under the 'doc' directory to generate it.
